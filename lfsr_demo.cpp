#include "lfsr.h"
#include <iostream>
#include <iomanip>
#include <vector>
#include <chrono>
#include <random>
#include <bitset>

/**
 * @brief Demonstrate LFSR functionality with different register sizes
 */
void demonstrateLFSR() {
    std::cout << "=== LFSR (Linear Feedback Shift Register) Demonstration ===\n\n";
    
    // Test different register sizes
    std::vector<uint8_t> sizes = {3, 4, 5, 8, 10, 12, 16};
    
    for (uint8_t size : sizes) {
        std::cout << "--- Register Size: " << static_cast<int>(size) << " bits ---\n";
        
        try {
            // Create LFSR with random seed
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dis(1, (1 << size) - 1);
            uint16_t seed = dis(gen);
            
            LFSR lfsr(size, seed);
            
            std::cout << "Polynomial: " << lfsr.getPolynomialString() << "\n";
            std::cout << "Initial state: " << lfsr.getStateString() << " (0x" 
                      << std::hex << std::setw(4) << std::setfill('0') 
                      << lfsr.getState() << std::dec << ")\n";
            std::cout << "Max period: " << lfsr.getMaxPeriod() << " bits\n";
            
            // Generate first 20 bits
            std::cout << "First 20 bits: ";
            for (int i = 0; i < 20; i++) {
                std::cout << (lfsr.nextBit() ? '1' : '0');
                if ((i + 1) % 4 == 0) std::cout << " ";
            }
            std::cout << "\n";
            
            // Test period completion
            std::cout << "Testing period completion...\n";
            auto start = std::chrono::high_resolution_clock::now();
            
            bool period_complete = lfsr.selfTest();
            
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
            
            std::cout << "Period test: " << (period_complete ? "PASSED" : "FAILED") 
                      << " (took " << duration.count() << " ms)\n";
            
            std::cout << "Current state: " << lfsr.getStateString() << "\n";
            std::cout << "Bits generated: " << lfsr.getPeriodCounter() << "\n\n";
            
        } catch (const std::exception& e) {
            std::cout << "Error: " << e.what() << "\n\n";
        }
    }
}

/**
 * @brief Demonstrate byte and word generation
 */
void demonstrateByteWordGeneration() {
    std::cout << "=== Byte and Word Generation Demo ===\n\n";
    
    LFSR lfsr(8, 0xAB); // 8-bit register with seed 0xAB
    
    std::cout << "8-bit LFSR with seed 0xAB\n";
    std::cout << "Polynomial: " << lfsr.getPolynomialString() << "\n\n";
    
    // Generate bytes
    std::cout << "Generated bytes (hex): ";
    for (int i = 0; i < 10; i++) {
        uint8_t byte = lfsr.nextByte();
        std::cout << "0x" << std::hex << std::setw(2) << std::setfill('0') 
                  << static_cast<int>(byte) << " ";
    }
    std::cout << std::dec << "\n\n";
    
    // Reset and generate words
    lfsr.reset(0x1234);
    std::cout << "16-bit LFSR with seed 0x1234\n";
    std::cout << "Generated words (hex): ";
    for (int i = 0; i < 5; i++) {
        uint16_t word = lfsr.nextWord();
        std::cout << "0x" << std::hex << std::setw(4) << std::setfill('0') 
                  << word << " ";
    }
    std::cout << std::dec << "\n\n";
}

/**
 * @brief Demonstrate sequence analysis
 */
void demonstrateSequenceAnalysis() {
    std::cout << "=== Sequence Analysis Demo ===\n\n";
    
    // Use a small register for easy analysis
    LFSR lfsr(4, 0x1); // 4-bit register, max period = 15
    
    std::cout << "4-bit LFSR analysis (max period: 15)\n";
    std::cout << "Polynomial: " << lfsr.getPolynomialString() << "\n\n";
    
    // Generate full sequence
    std::vector<bool> sequence = lfsr.generateSequence();
    
    std::cout << "Full sequence (" << sequence.size() << " bits): ";
    for (bool bit : sequence) {
        std::cout << (bit ? '1' : '0');
    }
    std::cout << "\n\n";
    
    // Analyze bit distribution
    int ones = 0, zeros = 0;
    for (bool bit : sequence) {
        if (bit) ones++; else zeros++;
    }
    
    std::cout << "Bit distribution:\n";
    std::cout << "  Ones:  " << ones << " (" << std::fixed << std::setprecision(1) 
              << (100.0 * ones / sequence.size()) << "%)\n";
    std::cout << "  Zeros: " << zeros << " (" << std::fixed << std::setprecision(1) 
              << (100.0 * zeros / sequence.size()) << "%)\n\n";
    
    // Check for patterns
    std::cout << "Pattern analysis:\n";
    int runs = 1;
    for (size_t i = 1; i < sequence.size(); i++) {
        if (sequence[i] != sequence[i-1]) runs++;
    }
    std::cout << "  Number of runs: " << runs << "\n";
    std::cout << "  Average run length: " << std::fixed << std::setprecision(2) 
              << (static_cast<double>(sequence.size()) / runs) << "\n\n";
}

/**
 * @brief Performance benchmark
 */
void benchmarkPerformance() {
    std::cout << "=== Performance Benchmark ===\n\n";
    
    const int iterations = 1000000; // 1 million bits
    
    for (uint8_t size : {8, 12, 16}) {
        LFSR lfsr(size, 1);
        
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < iterations; i++) {
            lfsr.nextBit();
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        double bits_per_second = (static_cast<double>(iterations) * 1000000.0) / duration.count();
        
        std::cout << size << "-bit LFSR: " << std::fixed << std::setprecision(0) 
                  << bits_per_second << " bits/sec\n";
    }
    std::cout << "\n";
}

/**
 * @brief Interactive mode for user testing
 */
void interactiveMode() {
    std::cout << "=== Interactive LFSR Testing ===\n\n";
    
    uint8_t size;
    std::cout << "Enter register size (3-16): ";
    std::cin >> size;
    
    if (size < 3 || size > 16) {
        std::cout << "Invalid size! Using default size 8.\n";
        size = 8;
    }
    
    uint16_t seed;
    std::cout << "Enter seed (0 for random): ";
    std::cin >> seed;
    
    if (seed == 0) {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1, (1 << size) - 1);
        seed = dis(gen);
        std::cout << "Using random seed: 0x" << std::hex << seed << std::dec << "\n";
    }
    
    LFSR lfsr(size, seed);
    
    std::cout << "\nLFSR Configuration:\n";
    std::cout << "  Size: " << static_cast<int>(size) << " bits\n";
    std::cout << "  Polynomial: " << lfsr.getPolynomialString() << "\n";
    std::cout << "  Max period: " << lfsr.getMaxPeriod() << " bits\n";
    std::cout << "  Initial state: " << lfsr.getStateString() << "\n\n";
    
    while (true) {
        std::cout << "Commands:\n";
        std::cout << "  b - generate next bit\n";
        std::cout << "  B - generate next byte\n";
        std::cout << "  w - generate next word\n";
        std::cout << "  s - show current state\n";
        std::cout << "  r - reset with new seed\n";
        std::cout << "  t - run self-test\n";
        std::cout << "  q - quit\n";
        std::cout << "Choice: ";
        
        char choice;
        std::cin >> choice;
        
        switch (choice) {
            case 'b': {
                bool bit = lfsr.nextBit();
                std::cout << "Next bit: " << (bit ? '1' : '0') << "\n";
                break;
            }
            case 'B': {
                uint8_t byte = lfsr.nextByte();
                std::cout << "Next byte: 0x" << std::hex << std::setw(2) << std::setfill('0') 
                          << static_cast<int>(byte) << std::dec << " (" 
                          << std::bitset<8>(static_cast<int>(byte)) << ")\n";
                break;
            }
            case 'w': {
                uint16_t word = lfsr.nextWord();
                std::cout << "Next word: 0x" << std::hex << std::setw(4) << std::setfill('0') 
                          << word << std::dec << "\n";
                break;
            }
            case 's': {
                std::cout << "Current state: " << lfsr.getStateString() 
                          << " (0x" << std::hex << lfsr.getState() << std::dec << ")\n";
                std::cout << "Bits generated: " << lfsr.getPeriodCounter() << "\n";
                break;
            }
            case 'r': {
                std::cout << "Enter new seed: ";
                std::cin >> seed;
                lfsr.reset(seed);
                std::cout << "Reset with seed: 0x" << std::hex << seed << std::dec << "\n";
                break;
            }
            case 't': {
                bool result = lfsr.selfTest();
                std::cout << "Self-test: " << (result ? "PASSED" : "FAILED") << "\n";
                break;
            }
            case 'q': {
                return;
            }
            default: {
                std::cout << "Invalid choice!\n";
                break;
            }
        }
        std::cout << "\n";
    }
}

int main() {
    std::cout << std::fixed << std::setprecision(2);
    
    try {
        // Run demonstrations
        demonstrateLFSR();
        demonstrateByteWordGeneration();
        demonstrateSequenceAnalysis();
        benchmarkPerformance();
        
        // Ask user if they want interactive mode
        std::cout << "Would you like to try interactive mode? (y/n): ";
        char choice;
        std::cin >> choice;
        
        if (choice == 'y' || choice == 'Y') {
            interactiveMode();
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    std::cout << "LFSR demonstration completed successfully!\n";
    return 0;
}